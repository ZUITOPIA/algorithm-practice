# 좋은 알고리즘 ?
# 시간 효율성 / 공간 효율성
# 컴퓨터의 자원(CPU의 시간이나 메모리)을 적게 사용하는 것, 실행 시간이 적은 것
### 임베디드 시스템과 같이 제한적인 하드웨어에서는 시간 효율성이 중요

# 효율성 분석
# 실제 실행시간은 프로그램에 의해 달라질 수 있음
### '이론적인 복잡도 분석'이 중요 (절대적인 시간을 측정하는 것 보다)

# 이론적인 알고리즘 복잡도 분석 시 중요한 것
# 1. '입력의 크기' == 입력 개수
# 2. 복잡도에 영향을 미치는 핵심 연산('기본 연산') 찾기
# 3. 입력의 크기가 증가함에 따라 처리시간이 '어떤 형태로 증가'하는가
# 4. '입력의 특성에 따라 알고리즘 효율성'에는 어떤 차이가 있는가
### 최악의 경우를 가장 많이 이용함 (최악의 경우를 대비하기 위함)

# 점근적 성능 분석 방법
# 차수가 가장 큰 항이 절대적인 영향 (ex. n^2 + n + 1 일때는 n^2 만 보아도 무방함)

# 점근적 표기법
# n이 무한대로 커질대의 복잡도를 간단히 표현하는 방법 (최고차항만을 계수없이 취함)
# 빅오 / 빅오메가 / 빅세타
### 위 세가지 정의는 다르지만 같은 의미로 이용되는 경우가 많음

# 빅오
##   복잡도 함수의 상한
##   2n - 3 == n^2 (같거나, 더 크게 표현 가능)
##   3n^2 + 4n != n (더 작게 표현 불가능)
# 빅오메가
##   복잡도 함수의 하한
##   2n^2 + 3n == n^2 (같거나, 더 작게 표현 가능)
##   3n != n^2 (더 크게 표현 불가능)
# 빅세타
##   샌드위치 (상한이면서 하한, 같은 차수로만 표현 가능)
##   2n^3 +3n == n^4 / 2n^3 +3n == n^2 (더 크게 / 작게 표현 불가능)

# 점근적 성능 클래스 크기비교
### 1 < logn < n < nlogn < n^2 < n^3 < 2^n < n!